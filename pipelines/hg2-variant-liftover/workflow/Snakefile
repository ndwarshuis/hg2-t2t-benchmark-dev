# pafs from here: https://drive.google.com/drive/u/1/folders/12_Y5Gvx50g6t9JVsRWdXWMp6L9tb3jJj
# query files from here: https://drive.google.com/drive/u/1/folders/1lqGkHjY7YL0Dvm-YWRpaIYDQILAo3P8K


# TODO actually use curl
rule download_query_vcf:
    output:
        "resources/query/query.vcf.gz",


# TODO actually use curl
rule download_query_bed:
    output:
        "resources/query/query.bed",


# TODO actually use curl
rule download_paf:
    output:
        "resources/paf/{hap}.paf.gz",


rule download_bench_vcf:
    output:
        "resources/bench/bench.vcf.gz",
    params:
        url="https://ftp-trace.ncbi.nlm.nih.gov/ReferenceSamples/giab/release/AshkenazimTrio/HG002_NA24385_son/NISTv4.2.1/GRCh38/HG002_GRCh38_1_22_v4.2.1_benchmark.vcf.gz",
    shell:
        "curl -Ss -q -L -o {output} {params.url}"


use rule download_bench_vcf as download_bench_bed with:
    output:
        "resources/bench/bench.bed",
    params:
        url="https://ftp-trace.ncbi.nlm.nih.gov/ReferenceSamples/giab/release/AshkenazimTrio/HG002_NA24385_son/NISTv4.2.1/GRCh38/HG002_GRCh38_1_22_v4.2.1_benchmark_noinconsistent.bed",


use rule download_bench_vcf as download_ref with:
    output:
        "resources/references/GRCh38.fa.gz",
    params:
        url="https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/000/001/405/GCA_000001405.15_GRCh38/seqs_for_alignment_pipelines.ucsc_ids/GCA_000001405.15_GRCh38_no_alt_analysis_set.fna.gz",


rule unzip_ref:
    input:
        rules.download_ref.output,
    output:
        "results/references/GRCh38.fa",
    shell:
        "gunzip -c {input} > {output}"


rule unzip_paf:
    input:
        rules.download_paf.output,
    output:
        "results/paf/{hap}.paf",
    shell:
        "gunzip -c {input} > {output}"


rule index_ref:
    input:
        rules.unzip_ref.output,
    output:
        rules.unzip_ref.output[0] + ".fai",
    conda:
        "envs/samtools.yml"
    shell:
        "samtools faidx {input} -o {output}"


# for testing
rule filter_query_vcf:
    input:
        rules.download_query_vcf.output,
    output:
        "results/query/filtered.vcf.gz",
    conda:
        "envs/samtools.yml"
    shell:
        """
        gunzip -c {input} | \
        grep -E '^(#|chr(21|22))' | \
        bgzip -c > {output}
        """


# for testing
rule filter_paf:
    input:
        rules.unzip_paf.output,
    output:
        "results/paf/{hap}_filtered.paf",
    shell:
        "grep -E '^chr(21|22)' {input} > {output}"


# for testing
use rule filter_query_vcf as filter_bench_vcf with:
    input:
        rules.download_bench_vcf.output,
    output:
        "results/bench/filtered.vcf.gz",


rule run_happy:
    input:
        refi=rules.index_ref.output,
        ref=rules.unzip_ref.output,
        bench_vcf=rules.filter_bench_vcf.output,
        bench_bed=rules.download_bench_bed.output,
        query_vcf=rules.filter_query_vcf.output,
        query_bed=rules.download_query_bed.output,
    output:
        "results/benchmark/happy/happy.vcf.gz",
    params:
        prefix=lambda wildcards, output: output[0].replace(".vcf.gz", ""),
    conda:
        "envs/happy.yml"
    log:
        "log/happy.log",
    threads: 8
    shell:
        """
        HGREF={input.ref} \
        hap.py \
        --engine vcfeval \
        --verbose \
        --threads {threads} \
        -f {input.bench_bed} \
        -o {params.prefix} \
        -T {input.query_bed} \
        {input.bench_vcf} {input.query_vcf} \
        > {log} 2>&1
        """


rule vcf_to_bed:
    input:
        rules.run_happy.output,
    output:
        "results/benchmark/bed/all_errors.bed",
    shell:
        """
        gunzip -c {input} | \
        sed '/^#/d' | \
        sed '/UNK/d' | \
        awk 'OFS="\t" {{ print $1, $2-1, $2+length($4)-1, $4, $5, $9, $10 }}' \
        > {output}
        """


rule filter_gt_errors:
    input:
        rules.vcf_to_bed.output,
    output:
        gt="results/benchmark/bed/gt_errors.bed",
        nogt="results/benchmark/bed/nogt_errors.bed",
    shell:
        """
        grep ':am:' {input} > {output.gt}
        grep -v ':am:' {input} > {output.nogt}
        """


rule filter_fp_errors:
    input:
        rules.filter_gt_errors.output.nogt,
    output:
        "results/benchmark/bed/fp_errors.bed",
    shell:
        "grep ':FP:' {input} > {output}"


rule filter_fn_errors:
    input:
        rules.filter_gt_errors.output.nogt,
    output:
        "results/benchmark/bed/fn_errors.bed",
    shell:
        "grep ':FN:' {input} > {output}"


def liftover_input(wildcards):
    l = wildcards.label
    if l == "fp":
        return rules.filter_fp_errors.output
    elif l == "fn":
        return rules.filter_fn_errors.output
    elif l == "gt":
        return rules.filter_gt_errors.output.gt
    else:
        assert False, "where did you learn to type? (wrong label)"


rule clone_liftover_scripts:
    output:
        directory("results/tools/liftover"),
    shell:
        """
        git clone \
        --depth 1 \
        --branch v0.2.0 \
        https://github.com/mobinasri/flagger.git \
        {output}
        """


rule run_liftover:
    input:
        paf=rules.filter_paf.output,
        bed=liftover_input,
        tooldir=rules.clone_liftover_scripts.output,
    output:
        projectable="results/projections/projectable_{hap}_{label}.bed",
        projected="results/projectsion/projected_{hap}_{label}.bed",
    threads: 8
    shell:
        """
        python {input.tooldir}/programs/src/project_blocks_multi_thread.py \
        --mode ref2asm \
        --paf {input.paf} \
        --blocks {input.bed} \
        --outputProjectable {output.projectable} \
        --outputProjection {output.projected} \
        --threads {threads}
        """


# TODO if we want we can filter the lifted beds after the fact


rule all:
    input:
        expand(
            rules.run_liftover.output,
            hap=["mat", "pat"],
            label=["fp", "fn", "gt"],
        ),
