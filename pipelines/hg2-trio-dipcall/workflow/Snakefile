from pathlib import Path
import re

src_dir = Path("resources")
src_asm_dir = src_dir / "asm"

res_dir = Path("results")
res_asm_dir = res_dir / "asm"
res_dip_dir = res_dir / "dipcall"


def child_url(wildcards):
    hap = wildcards.child_hap
    if hap == "pat":
        return "https://s3-us-west-2.amazonaws.com/human-pangenomics/T2T/HG002/assemblies/polishing/HG002/v0.7/v0.7.pat_X_EBV_MT.fasta"
    elif hap == "mat":
        return "https://s3-us-west-2.amazonaws.com/human-pangenomics/T2T/HG002/assemblies/polishing/HG002/v0.7/v0.7.mat_Y_EBV_MT.fasta"
    else:
        assert False, "Petrucci is not impressed with your fingers (wrong hap)"


def child_hap(wildcards):
    hap = wildcards.parent
    if hap == "father":
        return "pat"
    elif hap == "mother":
        return "mat"
    else:
        assert False, "Even Guido can type better than you (wrong parent)"


rule download_child_asm:
    output:
        src_asm_dir / "child" / "{child_hap}.fa",
    params:
        url=child_url,
    shell:
        "curl -Ss -q -L -o {output} {params.url}"


rule index_child_asm:
    input:
        rules.download_child_asm.output,
    output:
        res_asm_dir / "child" / "{child_hap}.mmi",
    conda:
        "envs/dipcall.yml"
    shell:
        "minimap2 -x asm5 -d {output} {input}"


# NOTE: the parental asms are on google drive and need to be downloaded manually
rule laboriously_obtain_parental_asms:
    output:
        src_asm_dir / "parents" / "{parent}" / "{parent_hap}.fa.gz",


rule run_dipcall:
    input:
        **{
            k: expand(
                rules.laboriously_obtain_parental_asms.output,
                parent_hap=h,
                allow_missing=True,
            )
            for k, h in [("h1", "pat"), ("h2", "mat")]
        },
        unpack(
            lambda wildcards: {
                k: expand(path, child_hap=child_hap(wildcards.parent))
                for k, path in [
                    ("ref", rules.download_child_asm.output),
                    ("ref_mmi", rules.index_child_asm.output),
                ]
            }
        ),
        par=get_male_bed,
    output:
        vcf=res_dip_dir / "{parent}.vcf.gz",
        make=res_dip_dir / "{parent}.mak",
    conda:
        "envs/dipcall.yml"
    params:
        prefix=lambda _, output: re.sub("\..*?", "", output[0]),
        male_bed=get_dipcall_par_param,
    log:
        "log/dipcall.log",
    shell:
        """
        run-dipcall \
            -t {threads} \
            -d {input.ref_mmi} \
            {params.extra} \
            {params.male_bed} \
            {params.prefix} \
            {input.ref} \
            {input.h1} \
            {input.h2} \
            > {output.make}

        make -j{threads} -f {outputmmake}
        """


# combinations to run: child pat vs father and child mat vs mother


rule all:
    input:
        expand(rules.run_dipcall.output, parent=["mother", "father"]),
