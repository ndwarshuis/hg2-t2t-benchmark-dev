from pathlib import Path
import re

src_dir = Path("resources")
src_asm_dir = src_dir / "asm"

res_dir = Path("results")
res_asm_dir = res_dir / "asm"
res_dip_dir = res_dir / "dipcall" / "{parent}"


def child_url(wildcards):
    hap = wildcards.child_hap
    if hap == "pat":
        return "https://s3-us-west-2.amazonaws.com/human-pangenomics/T2T/HG002/assemblies/polishing/HG002/v0.7/v0.7.pat_X_EBV_MT.fasta"
    elif hap == "mat":
        return "https://s3-us-west-2.amazonaws.com/human-pangenomics/T2T/HG002/assemblies/polishing/HG002/v0.7/v0.7.mat_Y_EBV_MT.fasta"
    else:
        assert False, "Petrucci is not impressed with your fingers (wrong hap)"


def child_hap(parent):
    if parent == "father":
        return "pat"
    elif parent == "mother":
        return "mat"
    else:
        assert False, "Even Guido can type better than you (wrong parent)"


rule download_child_asm:
    output:
        src_asm_dir / "child" / "{child_hap}.fa",
    params:
        url=child_url,
    shell:
        "curl -Ss -q -L -o {output} {params.url}"


rule index_child_asm:
    input:
        rules.download_child_asm.output,
    output:
        res_asm_dir / "child" / "{child_hap}.fai",
    conda:
        "envs/dipcall.yml"
    shell:
        "samtools faidx {input} > {output}"


# NOTE: the parental asms are on google drive and need to be downloaded manually
# HG3 hap1: https://drive.google.com/file/d/1qvrmf68uJ5VAesKNB_jdfmXuudCZd0Ys/view
# HG3 hap2: https://drive.google.com/file/d/1Jhc_erBgPVYapG4kPQt7LWJKIu4iagdk/view
# HG4 hap1: https://drive.google.com/file/d/1qgJf0LhjumYIp6XTzxL8OnjobwcQvDBd/view
# HG4 hap2: https://drive.google.com/file/d/1-gpix77eg7F9wFYRDS1ndD_oMwhxEYsB/view
rule laboriously_obtain_parental_asms:
    output:
        src_asm_dir / "parents" / "{parent}" / "{parent_hap}.fa.gz",


rule run_dipcall:
    input:
        unpack(
            lambda wildcards: {
                k: expand(path, child_hap=child_hap(wildcards.parent))
                for k, path in [
                    ("ref", rules.download_child_asm.output),
                    ("ref_idx", rules.index_child_asm.output),
                ]
            }
        ),
        **{
            k: expand(
                rules.laboriously_obtain_parental_asms.output,
                parent_hap=h,
                allow_missing=True,
            )
            for k, h in [("h1", "pat"), ("h2", "mat")]
        },
    output:
        vcf=res_dip_dir / "hg2.dip.vcf.gz",
        make=res_dip_dir / "hg2.dip.mak",
    conda:
        "envs/dipcall.yml"
    params:
        prefix=lambda _, output: re.sub("\.dip.*", "", output.make),
    log:
        res_dip_dir / "dip.log",
    threads: 8
    shell:
        """
        run-dipcall \
            -z 200000,10000 \
            -t {threads} \
            -d {input.ref_idx} \
            {params.prefix} \
            {input.ref} \
            {input.h1} \
            {input.h2} \
            > {output.make}

        make -j{threads} -f {output.make}
        """


rule all:
    input:
        expand(rules.run_dipcall.output, parent=["mother", "father"]),
